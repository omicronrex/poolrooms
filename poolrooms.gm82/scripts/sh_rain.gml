return shader_pixel_create_base64("
    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
")

/*


    #define MARCH_STEPS 100
    #define RAIN_STEPS 50
    #define SHAD_STEP 30

    #define time iTime

    float PI = acos(-1.0);

    float sph(vec3 p, float r) {
      return length(p)-r;
    }

    float cyl(vec2 p, float r) {
      return length(p)-r;
    }

    float box(vec3 p, vec3 s) {
      vec3 ap = abs(p)-s;
      return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));
    }

    mat2 rot(float a) {
      float ca=cos(a);
      float sa=sin(a);
      return mat2(ca,sa,-sa,ca);
    }

    vec3 tunnel(vec3 p) {
      //return vec3(0.0);
      vec3 off = vec3(0.0);
      off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;
      off.y += sin(p.z*0.5)*0.2 + p.z*0.3;
      return off;
    }

    float smin(float a, float b, float h) {
      float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);
      return mix(a, b, k) - k*(1.0-k)*h;
    }

    float map(vec3 p) {

      float water = 10.0-p.y-p.z*0.3;

        return water;
      p += tunnel(p);

      vec3 rp = p;
      float sizerepeat = 2.0;
      rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;

      rp.yz *= rot(-rp.z*0.2);
      float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));


      vec3 rp4 = rp + vec3(0,-0.8,0);
      rp4.x += sin(p.z*8.0)*0.05;
      rp4.y += cos(p.z*7.0)*0.05;
      float size4 = 0.14;
      rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;
      float bricks = box(rp4, vec3(0.05))-0.015;
      bricks = max(bricks, bridge - 0.05);

      bridge = smin(bridge, bricks, 0.09);


      rp.x = abs(rp.x) - 1.0;

      float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));
      vec3 rp2 = rp;
      float size2 = 0.2;
      rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;
      bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));

      bridge = min(bridge, bar);

      vec3 rp3 = p + vec3(1,0,1.0);
      float size3 = sizerepeat * 2.0;
      rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;
      float def = sin(rp3.y*17.0+2.0)*0.5+0.5;
      def = sin(rp3.y*10.0 + def*3.0);
      def = smoothstep(0.0,1.0,def);
      def = smoothstep(0.0,1.0,def);
      float lsize = 0.05 + (def)*0.02;
      float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);

      vec3 lpos = rp3 + vec3(0,1,0);
      float top = sph(lpos, 0.3);
      top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));

      lpos.y = max(abs(lpos.y)-0.1,0.0);
      //lamp = min(lamp, sph(lpos, 0.12));

      //lamp = min(lamp, top);
      lpos = abs(lpos)-0.1;
      lpos.xz *= rot(PI*0.25);
      //lamp = max(lamp, -box(lpos, vec3(0.05,0.2,0.05)));
      bridge = min(bridge, lamp);

      bridge = min(bridge, water);

      return bridge;

    }


    float lighting(vec3 p) {

      p += tunnel(p);

      float sizerepeat = 2.0;
      vec3 rp3 = p + vec3(1,0,1.0);
      float size3 = sizerepeat * 2.0;
      rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;

      vec3 lpos = rp3 + vec3(0,1,0);
      float top = sph(lpos, 0.3);
      return sph(lpos, 0.12);
    }

    vec3 norm(vec3 p) {
      vec2 off=vec2(0.01,0);
      return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));
    }

    vec3 getlightdir(vec3 p) {
      vec2 off=vec2(0.01,0);
      return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));
    }

    float rnd(float t) {

      return fract(sin(t*745.523)*7894.552);

    }

    float rain(vec3 p) {

      p.y -= time*4.0;
      p.xy *= 60.0;

      p.y += rnd(floor(p.x))*80.0;

      return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);
    }

    float ripple(vec3 p) {

      float t2 = time*5.0;

      float size3 = 0.2;
      vec3 rp3 = p + vec3(1,0,1.0);

      float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));
      rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;


      float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);
      float looplen = 0.5;
      float off = rnd(id * 75.5238);
      float fl = 1.0-fract(time*looplen + off);
      fl = pow(fl,10.0);
      //float il = floor(time*looplen);
      float r2 = cos(r*10.0 + t2) * fl;


      return r2*r;

    }

    float ripples(vec3 p) {

      float r = 0.0;
      for(int i=0; i<5; ++i) {
        vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));
        cur *= rnd(float(i)+12.71)*0.2+0.8;
        cur *= 3.0;
        r += ripple(cur);
      }
      return r;
    }

    vec3 ripplenorm(vec3 n, vec3 p) {

      vec2 off = vec2(0.01,0.0);

      vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));
      n.xz += rn.xz * (abs(n.y));
      //n.y *= rn.y;
      return n;

    }

    float rnd(vec2 uv) {
      return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));
    }

    float curve(float t, float r, float p) {
      float g = t/r;
      return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));
    }

    float shadow(vec3 s, vec3 r, float maxdist, float rn) {
      float shad = 1.0;
      int steps = SHAD_STEP;
      vec3 raystep = r*maxdist/float(steps);
      vec3 p = s + raystep*rn;
      for(int i=0; i<steps; ++i) {
        float d = map(p);
        if(d<0.01) {
          shad = 0.0;
          break;
        }
        p += raystep;
      }
      return shad;
    }

    void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {

      vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);
      uv -= 0.5;
      uv /= vec2(iResolution.y / iResolution.x, 1);

      vec3 s = vec3(1,sin(time*0.3)*0.2,-3);
      vec3 t = vec3(0,0,0);


      vec3 r = normalize(vec3(-uv,0.7));



      vec3 p = s;
      float dd=0.0;
      for(int i=0; i<MARCH_STEPS; ++i) {
        float d = map(p);
        if(d<0.001) {
          break;
        }
        if(dd>100.0) {
          dd=100.0;
          break;
        }
        p+=r*d;
        dd+=d;
      }

      vec3 col = vec3(0.0);
      vec3 n = norm(p);

      n = ripplenorm(n, p);


      float lightning = curve(time, 0.2, 0.1);
      //float idlightning = floor(time/0.4-0.5);
      float idlightning = 0.0;

      float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);
      vec3 lmoon = normalize(vec3(-8,-3,-3.0 + sin(idlightning)*3.0));

      float shad = shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));

      col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;

      vec3 l = -getlightdir(p);
      float ldist = lighting(p);

      vec3 h = normalize(l-r);

      //col += fract(length(light-p)*10.5);
      //vec3 l = normalize(light-p);
      //float ldist = dot(light-p, light-p);
      col += max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);

      float at = 0.0;
      vec3 raining = vec3(0.0);
      int steps = RAIN_STEPS;
      float stepsize = 30.0 / float(steps);
      vec3 raystep = r * stepsize / r.z;
      //vec3 raypos = s + raystep;
      for(int i=0; i<steps; ++i) {
        vec3 raypos = s + raystep * (float(i)+1.0);
        float tot = length(raypos-s);

        if(tot>dd) break;
        float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);


        vec3 ldir = getlightdir(raypos);
        float l2dist = lighting(raypos);
        float curlight = 1.0/pow(l2dist,2.0);

        vec3 rainpos = raypos;
        rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);
        rainpos.xy += rnd(float(i))*vec2(7.52,13.84);
        raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));

        //vec3 ldir = light-raypos;
        at += 0.04*curlight * fog2;
        //raypos += raystep;
      }
      col += at;
      col += raining;

      //col = ripplenorm(n, vec3(-uv.x,0.0,-uv.y));

      col = pow(col, vec3(0.4545));

      fragColor = vec4(col, 1);
    }
*/
